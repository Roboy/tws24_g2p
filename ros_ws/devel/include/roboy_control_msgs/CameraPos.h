// Generated by gencpp from file roboy_control_msgs/CameraPos.msg
// DO NOT EDIT!


#ifndef ROBOY_CONTROL_MSGS_MESSAGE_CAMERAPOS_H
#define ROBOY_CONTROL_MSGS_MESSAGE_CAMERAPOS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace roboy_control_msgs
{
template <class ContainerAllocator>
struct CameraPos_
{
  typedef CameraPos_<ContainerAllocator> Type;

  CameraPos_()
    : m00(0.0)
    , m01(0.0)
    , m02(0.0)
    , m03(0.0)
    , m10(0.0)
    , m11(0.0)
    , m12(0.0)
    , m13(0.0)
    , m20(0.0)
    , m21(0.0)
    , m22(0.0)
    , m23(0.0)
    , m30(0.0)
    , m31(0.0)
    , m32(0.0)
    , m33(0.0)  {
    }
  CameraPos_(const ContainerAllocator& _alloc)
    : m00(0.0)
    , m01(0.0)
    , m02(0.0)
    , m03(0.0)
    , m10(0.0)
    , m11(0.0)
    , m12(0.0)
    , m13(0.0)
    , m20(0.0)
    , m21(0.0)
    , m22(0.0)
    , m23(0.0)
    , m30(0.0)
    , m31(0.0)
    , m32(0.0)
    , m33(0.0)  {
  (void)_alloc;
    }



   typedef float _m00_type;
  _m00_type m00;

   typedef float _m01_type;
  _m01_type m01;

   typedef float _m02_type;
  _m02_type m02;

   typedef float _m03_type;
  _m03_type m03;

   typedef float _m10_type;
  _m10_type m10;

   typedef float _m11_type;
  _m11_type m11;

   typedef float _m12_type;
  _m12_type m12;

   typedef float _m13_type;
  _m13_type m13;

   typedef float _m20_type;
  _m20_type m20;

   typedef float _m21_type;
  _m21_type m21;

   typedef float _m22_type;
  _m22_type m22;

   typedef float _m23_type;
  _m23_type m23;

   typedef float _m30_type;
  _m30_type m30;

   typedef float _m31_type;
  _m31_type m31;

   typedef float _m32_type;
  _m32_type m32;

   typedef float _m33_type;
  _m33_type m33;





  typedef boost::shared_ptr< ::roboy_control_msgs::CameraPos_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::roboy_control_msgs::CameraPos_<ContainerAllocator> const> ConstPtr;

}; // struct CameraPos_

typedef ::roboy_control_msgs::CameraPos_<std::allocator<void> > CameraPos;

typedef boost::shared_ptr< ::roboy_control_msgs::CameraPos > CameraPosPtr;
typedef boost::shared_ptr< ::roboy_control_msgs::CameraPos const> CameraPosConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::roboy_control_msgs::CameraPos_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::roboy_control_msgs::CameraPos_<ContainerAllocator1> & lhs, const ::roboy_control_msgs::CameraPos_<ContainerAllocator2> & rhs)
{
  return lhs.m00 == rhs.m00 &&
    lhs.m01 == rhs.m01 &&
    lhs.m02 == rhs.m02 &&
    lhs.m03 == rhs.m03 &&
    lhs.m10 == rhs.m10 &&
    lhs.m11 == rhs.m11 &&
    lhs.m12 == rhs.m12 &&
    lhs.m13 == rhs.m13 &&
    lhs.m20 == rhs.m20 &&
    lhs.m21 == rhs.m21 &&
    lhs.m22 == rhs.m22 &&
    lhs.m23 == rhs.m23 &&
    lhs.m30 == rhs.m30 &&
    lhs.m31 == rhs.m31 &&
    lhs.m32 == rhs.m32 &&
    lhs.m33 == rhs.m33;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::roboy_control_msgs::CameraPos_<ContainerAllocator1> & lhs, const ::roboy_control_msgs::CameraPos_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace roboy_control_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::roboy_control_msgs::CameraPos_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::roboy_control_msgs::CameraPos_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::roboy_control_msgs::CameraPos_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8903cef6b8f5901e6c1b1feeb6a5a6d1";
  }

  static const char* value(const ::roboy_control_msgs::CameraPos_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8903cef6b8f5901eULL;
  static const uint64_t static_value2 = 0x6c1b1feeb6a5a6d1ULL;
};

template<class ContainerAllocator>
struct DataType< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
{
  static const char* value()
  {
    return "roboy_control_msgs/CameraPos";
  }

  static const char* value(const ::roboy_control_msgs::CameraPos_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 m00\n"
"float32 m01\n"
"float32 m02\n"
"float32 m03\n"
"\n"
"float32 m10\n"
"float32 m11\n"
"float32 m12\n"
"float32 m13\n"
"\n"
"float32 m20\n"
"float32 m21\n"
"float32 m22\n"
"float32 m23\n"
"\n"
"float32 m30\n"
"float32 m31\n"
"float32 m32\n"
"float32 m33\n"
;
  }

  static const char* value(const ::roboy_control_msgs::CameraPos_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.m00);
      stream.next(m.m01);
      stream.next(m.m02);
      stream.next(m.m03);
      stream.next(m.m10);
      stream.next(m.m11);
      stream.next(m.m12);
      stream.next(m.m13);
      stream.next(m.m20);
      stream.next(m.m21);
      stream.next(m.m22);
      stream.next(m.m23);
      stream.next(m.m30);
      stream.next(m.m31);
      stream.next(m.m32);
      stream.next(m.m33);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CameraPos_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::roboy_control_msgs::CameraPos_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::roboy_control_msgs::CameraPos_<ContainerAllocator>& v)
  {
    s << indent << "m00: ";
    Printer<float>::stream(s, indent + "  ", v.m00);
    s << indent << "m01: ";
    Printer<float>::stream(s, indent + "  ", v.m01);
    s << indent << "m02: ";
    Printer<float>::stream(s, indent + "  ", v.m02);
    s << indent << "m03: ";
    Printer<float>::stream(s, indent + "  ", v.m03);
    s << indent << "m10: ";
    Printer<float>::stream(s, indent + "  ", v.m10);
    s << indent << "m11: ";
    Printer<float>::stream(s, indent + "  ", v.m11);
    s << indent << "m12: ";
    Printer<float>::stream(s, indent + "  ", v.m12);
    s << indent << "m13: ";
    Printer<float>::stream(s, indent + "  ", v.m13);
    s << indent << "m20: ";
    Printer<float>::stream(s, indent + "  ", v.m20);
    s << indent << "m21: ";
    Printer<float>::stream(s, indent + "  ", v.m21);
    s << indent << "m22: ";
    Printer<float>::stream(s, indent + "  ", v.m22);
    s << indent << "m23: ";
    Printer<float>::stream(s, indent + "  ", v.m23);
    s << indent << "m30: ";
    Printer<float>::stream(s, indent + "  ", v.m30);
    s << indent << "m31: ";
    Printer<float>::stream(s, indent + "  ", v.m31);
    s << indent << "m32: ";
    Printer<float>::stream(s, indent + "  ", v.m32);
    s << indent << "m33: ";
    Printer<float>::stream(s, indent + "  ", v.m33);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROBOY_CONTROL_MSGS_MESSAGE_CAMERAPOS_H
